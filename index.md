### APUE
****

#### 进程关系

##### 终端登录
  当系统自举时，内核创建进程ID为1的进程，也就是init进程，init进程使系统进入多用户模式，读取由系统管理者创建的/etc/ttys，对每一个允许登录的终端调用一次fork，生成的子进程则exec getty程序。getty对终端设备调用open函数，设备打开后getty输出“login:”之类的信息等待用户输入用户名，用户名输入后getty的工作便完成了，最终调用login程序。
  在这个过程中，init以空环境调用getty，getty以终端名和在gettytab中说明的环境字符串为Login创建一个环境并用-p通知其保留该环境。
  login得到了用户名，所以可以调用getpwnam活动相应用户的口令文件登录项，然后调用getpass显示提示并读入用户输入的口令，调用crypt将口令加密，在将其与阴影口令文件中登录项的pw_passwd字段相比较。如果用户反复登录失败，则login调用exit表示登录过程失败，父进程init了解后，再次调用fork，而后又执行了getty，不断重复。
  如果登录成功，则：
  -将当前工作目录改为该用户的起始目录。
  -调用chown更改终端所有权使登录用户成为它的所有者。
  -将对该终端设备的访问权限改为用户读和写。
  -调用setgid和intgroups设置进程组id
  -用login得到的所有信息初始化环境
  -login进程更改为登录用户的用户ID并调用他的登录shell。
  登录shell会读取其启动文件，通常会改变某些环境变量并加入很多环境变量，最后，显示shell提示符。
##### 网络登录
  为了使一个软件既能处理终端登录又能处理网络登录，系统使用了一种叫做伪终端的*软件驱动程序*。它仿真串行终端的运行行为，并将终端操作映射为网络操作，反之亦然。
  当系统启动时，init调用一个shell，执行/etx/rc，启动一个守护进程inetd。shell脚本终止后，inetd的父进程便变为了init。inetd等待TCP/IP连接请求到达，到达后执行一次fork并exec适当的程序。然后该程序打开一个伪终端设备，并fork一个子进程执行login程序，父进程则处理网络连接的通信。父进程和子进程直接通过伪终端相连。

##### 进程组
  进程组是一个或多个进程的集合，通常是在同一作业中结合起来的。
 ```
 #include <unistd.h>
 pid_t getpgrp(void)
 int setpgid(pid_t pid , pid_t pgid)
 ```
 第一个函数返回调用进程的组ID，第二个设置第一个参数的组ID，若相同，则该进程成为进程组组长。若pid是0，使用调用者的进程ID，若pgid是0，则由pid指定的进程ID用作组ID。
 
##### 会话
  会话是一个或多个进程组的集合。
  ```
  #include <unistd.h>
  pid_t setsid(void);
  ```
  调用该函数的进程若不是进程组的组长，则创建一个新会话，该进程成为*会话首进程*并成为一个新进程组的组长，同时保证该进程在调用函数后不存在控制终端。若该进程已经是一个组长，则函数返回出错。

##### 控制终端
  -一个会话可以有一个控制终端，一般为终端设备或伪终端设备。
  -建立于控制终端连接的会话首进程为控制进程。
  -进程组可被分为（一个）前台进程组和（一个或多个）后台进程组。
  -中断键和退出键将信号发送至前台进程组中所有进程。
  -终端接口检测到网络断开则将挂断信号发送给会话首进程。































#### 进程控制
***
##### 函数exec

调用exec并不创建新进程，所以进程ID并不会改变，exec只是用磁盘上的一个新程序替换了当前进程的*正文段、数据段、对端和栈端*。
exit函数和wait函数处理终止和等待终止，fork用来创建新进程，exec可以初始执行新的程序，这些是基本的进程控制原语。

7个不同版本exec函数，其中第一个参数用路径名。文件名或文件描述符提供执行程序，随后参数按不同版本函数以不同方式向将要执行的程序提供参数。

对于路径名，若包含/则将其视为路径名，否则按PATH环境变量搜索。
###### PATH变量
PATH变量包含一张目录表，目录之间用冒号分割。






