### APUE
****

#### 进程关系

##### 终端登录
  当系统自举时，内核创建进程ID为1的进程，也就是init进程，init进程使系统进入多用户模式，读取由系统管理者创建的/etc/ttys，对每一个允许登录的终端调用一次fork，生成的子进程则exec getty程序。getty对终端设备调用open函数，设备打开后getty输出“login:”之类的信息等待用户输入用户名，用户名输入后getty的工作便完成了，最终调用login程序。
  在这个过程中，init以空环境调用getty，getty以终端名和在gettytab中说明的环境字符串为Login创建一个环境并用-p通知其保留该环境。
  login得到了用户名，所以可以调用getpwnam活动相应用户的口令文件登录项，然后调用getpass显示提示并读入用户输入的口令，调用crypt将口令加密，在将其与阴影口令文件中登录项的pw_passwd字段相比较。如果用户反复登录失败，则login调用exit表示登录过程失败，父进程init了解后，再次调用fork，而后又执行了getty，不断重复。
  如果登录成功，则：
  -将当前工作目录改为该用户的起始目录。
  -调用chown更改终端所有权使登录用户成为它的所有者。
  -将对该终端设备的访问权限改为用户读和写。
  -调用setgid和intgroups设置进程组id
  -用login得到的所有信息初始化环境
  -login进程更改为登录用户的用户ID并调用他的登录shell。
  登录shell会读取其启动文件，通常会改变某些环境变量并加入很多环境变量，最后，显示shell提示符。
##### 网络登录
  为了使一个软件既能处理终端登录又能处理网络登录，系统使用了一种叫做伪终端的*软件驱动程序*。它仿真串行终端的运行行为，并将终端操作映射为网络操作，反之亦然。
  当系统启动时，init调用一个shell，执行/etx/rc，启动一个守护进程inetd。shell脚本终止后，inetd的父进程便变为了init。inetd等待TCP/IP连接请求到达，到达后执行一次fork并exec适当的程序。
  
  

































#### 进程控制
***
##### 函数exec

调用exec并不创建新进程，所以进程ID并不会改变，exec只是用磁盘上的一个新程序替换了当前进程的*正文段、数据段、对端和栈端*。
exit函数和wait函数处理终止和等待终止，fork用来创建新进程，exec可以初始执行新的程序，这些是基本的进程控制原语。

7个不同版本exec函数，其中第一个参数用路径名。文件名或文件描述符提供执行程序，随后参数按不同版本函数以不同方式向将要执行的程序提供参数。

对于路径名，若包含/则将其视为路径名，否则按PATH环境变量搜索。
###### PATH变量
PATH变量包含一张目录表，目录之间用冒号分割。






